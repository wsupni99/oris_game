## Содержание
- [ТЗ](#Задание)
- [Установка и запуск](#запуск)
- [Протокол обмена данными](#протокол-обмена-данными)
- [Git-шпаргалка](#шпаргалка-по-git)
- [Сервер: базовая сеть и модель](#сервер-базовая-сеть-и-модель)
- [Протокол и сообщения](#протокол-и-сообщения)
- [Логика режимов и таймер раундов](#логика-режимов-и-таймер-раундов)
---

## Задание

**Цель:** Реализовать сетевую игру для 2+ игроков на Java (JavaFX + сокеты). Client-Server-Client архитектура. Собственный протокол с 4+ типами сообщений. GUI с рисованием (Graphics) и чатом. Многопоточность для сети/интерфейса.

**Репозиторий преподавателя:** В 11_402 есть примеры сокетов (Сокеты1/2 записи). Бери структуру Client/Server оттуда.

**Требования к коду (строго):**

- Только чистые сокеты + JavaFX (без Spring/Netty).
- Минимум комментариев.
- Каждый в группе знает весь код.
- Протокол: JSON/байты с типами сообщений (минимум 4 видимых игроку).
- Рисование: Canvas с Graphics2D для рисовалки.
- Многопоточность: ExecutorService для сетевых задач.


## Режимы игры

### 1. "Угадай что рисую" (2+ игрока)

- Сервер: Создаёт комнату (порт 8080).
- Клиенты: Подключаются по IP:порт.
- Админ (хост) рисует на Canvas (линия, цвет, стирание).
- Остальные: Чат для загаданного слова + поле ввода.
- Детект: Сервер сравнивает текст с загадкой (простой match).
- Видимые сообщения:

1. `DRAW` - координаты мазка (x,y,цвет).
2. `GUESS` - текст догадки.
3. `CORRECT` - "Угадал! Слово: ...".
4. `CHAT` - обычные сообщения.


### 2. "Глухой телефон" (4+ игрока)

- Админ создаёт комнату, все жмут "Готов".
- Админ жмёт "Старт" + таймер раунда (30-60с).
- Раунды:

1. Все пишут предложение (текст → сервер).
2. Сдвиг: Каждый получает текст предыдущего → рисует.
3. Сдвиг: Каждый получает рисунок следующего → описывает текстом.
4. Повтор до круга.
- Финал: Сервер шлёт последовательность (текст1 → рис1 → текст2 → рис2...).
- Видимые сообщения:

1. `TEXT_SUBMIT` - отправка текста/описания.
2. `DRAW_UPDATE` - мазки для рисовалки.
3. `NEXT_ROUND` - "Получили: [текст/картинка]".
4. `FINAL_CHAIN` - вся цепочка.

## Архитектура (Client/Server) — JavaFX

Server:
- ServerSocket (8080)
- HashMap<Socket, Player> (игроки)
- ExecutorService для обработки клиентов
- GameState (roomId, режим, раунд, таймер)

Client:
- Socket → ObjectOutputStream/InputStream
- JavaFX Stage/Scene
- Canvas (javafx.scene.canvas.Canvas) + GraphicsContext для рисования
- VBox/HBox/BorderPane для раскладки
- TextArea (чат), TextField (ввод), Button (Готов/Старт/Отправить), Label (таймер/статус)
- Отдельный поток для сети + Platform.runLater(...) для обновления UI

Протокол (JSON пример):
{ "type": "DRAW", "data": {x:10,y:20,color:"red",size:2} }
{ "type": "GUESS", "data": "кот" }


## GUI и рисование (3 балла) — JavaFX

- Компоненты: Button (Готов/Старт/Очистить), TextField (ввод), TextArea (чат/цепочка), ComboBox<String> (цвета), Label (таймер/статус).
- Рисование: Canvas, обработчики setOnMousePressed / setOnMouseDragged → GraphicsContext.strokeLine(...). Сохранять strokes как List<StrokeDto> (последовательность точек) для отправки/рендера.
- Адаптивность: BorderPane/ VBox / HBox, привязки по ширине/высоте (bind), использование Scene и resizeable Stage; обновление Canvas через перерисовку по данным с сервера в Platform.runLater.


**Дедлайн:** Прототип к 20.12, финал к 25.12. 

- - -

## Запуск
```mvn javafx:run```

---
# Протокол обмена данными

Все сообщения передаются в JSON между клиентом и сервером через TCP-сокеты.

## Структура сообщения

- `type` — тип сообщения (JOIN, CHAT, DRAW и т.д.)
- `roomId` — ID комнаты
- `playerId` — ID отправителя
- `playerName` — имя отправителя
- `payload` — данные сообщения

---

## Типы сообщений

| Тип | Направление | Описание |
|-----|-------------|---------|
| JOIN | Клиент → Сервер | Присоединение к комнате (gameMode, isHost) |
| CHAT | Клиент → Сервер → Все | Сообщение в чате (text) |
| DRAW | Клиент → Сервер → Все | Мазок на холсте режима 1 (x1, y1, x2, y2, color, size) |
| GUESS | Клиент → Сервер | Угадывание слова режима 1 (guess) |
| CORRECT | Сервер → Все | Уведомление об угадывании (correctPlayer, word, score) |
| READY | Клиент → Сервер | Игрок готов режима 2 (ready) |
| START | Сервер → Все | Начало игры режима 2 (roundDuration, totalPlayers, stage) |
| TEXT_SUBMIT | Клиент → Сервер | Отправка текста режима 2 (text, stage) |
| ROUND_UPDATE | Сервер → Все | Переход этапа режима 2 (stage, content, contentType, roundNumber) |
| FINAL_CHAIN | Сервер → Все | Финальная цепочка режима 2 (chains с текстами и рисунками) |
| ERROR | Сервер → Клиент | Ошибка сервера (code, message) |

---

## Коды ошибок

| Код | Описание |
|-----|---------|
| 400 | Некорректное сообщение |
| 403 | Нет прав (только для хоста) |
| 404 | Комната не найдена |
| 409 | Игра уже началась |
| 412 | Недостаточно игроков |


---

# Шпаргалка по Git

Пользуйтесь верхним меню **Git** или горячими клавишами. Командная строка не нужна.

## 1. Начало работы (Clone)
*Если проекта еще нет на компьютере:*
1. **File** → **New** → **Project from Version Control...**
2. Вставьте ссылку на репозиторий (URL).
3. Нажмите **Clone**.

## 2. Перед началом работы (Pull)
*Всегда делайте это перед тем, как писать код, чтобы не было конфликтов:*
1. Нажмите на синюю стрелку `⬇` в правом верхнем углу (или **Ctrl + T**).
2. Выберите `Merge` в окне (если спросит) и нажмите **OK**.

## 3. Сохранение изменений (Commit)
*Когда написали часть кода и хотите «зафиксировать» его:*
1. Нажмите **Ctrl + K** (или вкладка **Commit** слева).
2. Отметьте галочками нужные файлы.
3. Напишите понятный комментарий (напр: `feat: добавил холст для рисования`).
4. Нажмите кнопку **Commit** (только сохранит локально) или стрелочку рядом → **Commit and Push** (сразу отправит на GitHub).

## 4. Отправка на GitHub (Push)
*Если сделали просто Commit, его нужно «залить» в облако:*
1. Нажмите **Ctrl + Shift + K** (или зелёная стрелка `⬆` в углу).
2. Нажмите **Push**.

## 5. Если возник конфликт (Conflicts)
*Если вы и напарник изменили одну и ту же строку:*
1. При `Pull` или `Push` вылезет окно **Conflicts**.
2. Нажмите **Merge...**.
3. Откроется три окна:
    - **Слева (Your):** ваш код.
    - **Справа (Theirs):** код напарника.
    - **Центр (Result):** что получится в итоге.
4. Нажимайте на стрелочки `>>`, чтобы перенести нужные изменения в центр.
5. Когда закончите, нажмите **Apply**.

## 6. Как не сломать проект (Золотые правила)
1. **Pull** — каждое утро/вечер перед работой.
2. **Commit** — после каждой законченной маленькой задачи.
3. **Сообщения** — пишите честно, что сделали в коммите.
4. **Общение** — если лезете в файлы напарника, лучше предупредите в чате.

---
**Горячие клавиши для запоминания:**
- `Ctrl + T` — Обновить (Pull)
- `Ctrl + K` — Закоммитить (Commit)
- `Ctrl + Shift + K` — Отправить (Push)

---
## Сервер: базовая сеть и модель

### 1. Архитектура пакетов

- `ru.itis.garticphone.common`
    - `MessageType` — enum с типами сообщений протокола.
    - `Message` — структура одного JSON-сообщения (type, roomId, playerId, playerName, payload).
- `ru.itis.garticphone.client`
    - `PlayerState` — enum состояний игрока на стороне сервера.
    - `Player` — серверное представление подключённого игрока (метаданные + сокет + потоки).
- `ru.itis.garticphone.server`
    - `GameServer` — основной сервер: поднимает ServerSocket, принимает клиентов, обрабатывает сообщения.
    - `GameState`/`GameMode` — состояние комнаты (roomId, режим, список игроков, раунд, таймер).

### 2. Сетевой слой сервера

#### 2.1. Запуск сервера

- `GameServer` поднимает `ServerSocket` на порту `8080`.
- Для обработки клиентов используется `ExecutorService` (`newCachedThreadPool`).
- Каждый новый `Socket` от `accept()` передаётся в пул через `executorService.submit(() -> handleClient(socket))`.

#### 2.2. Модель игрока

`Player` инкапсулирует данные о клиенте:

- `id` — уникальный идентификатор игрока на сервере.
- `name` — имя/ник игрока.
- `state` (`PlayerState`) — состояние: `CONNECTED`, `IN_LOBBY`, `IN_GAME`, `DISCONNECTED`.
- `socket` — TCP-соединение с клиентом.
- `in` / `out` — `BufferedReader` и `PrintWriter` для приёма и отправки строк.

Сервер хранит всех игроков в `Map<Socket, Player> players`.

### 3. Протокол сообщений

#### 3.1. Типы сообщений

`MessageType` определяет фиксированный набор типов:

- `JOIN`, `CHAT`, `DRAW`, `GUESS`, `CORRECT`,
- `READY`, `START`, `TEXT_SUBMIT`, `ROUND_UPDATE`, `FINAL_CHAIN`, `ERROR`.

Это исключает магические строки и гарантирует, что протокол использует только корректные типы.

#### 3.2. Формат сообщения

Класс `Message` задаёт контракт JSON-сообщения:

- `type` — `MessageType` (например, `CHAT`).
- `roomId` — идентификатор комнаты.
- `playerId` — идентификатор отправителя.
- `playerName` — имя отправителя.
- `payload` — строковые данные (текст чата, JSON с координатами мазков, код ошибки и т.д.).

На проводе сообщение передаётся как одна JSON-строка, совместимая со структурой `Message`.

### 4. Цикл приёма/отправки на сервере

#### 4.1. Приём сообщений

Метод `handleClient(Socket socket)`:

- Создаёт потоки `BufferedReader in` и `PrintWriter out`.
- Регистрирует нового игрока (`Player`) и кладёт его в `players`.
- Входит в цикл:

    - читает строку: `line = in.readLine();`
    - парсит её в `Message message = parseMessage(line);`
    - при ошибке парсинга отправляет клиенту `ERROR` с кодом `400`.
    - передаёт сообщение в `routeMessage(player, message)` для логики.

Цикл работает до разрыва соединения. После выхода игрок удаляется из `players`, сокет закрывается.

#### 4.2. Отправка сообщений

- Для ответа/бродкаста сервер создаёт `Message` и преобразует его в JSON-строку методом `toJson(Message)`.
- Для чата используется `broadcastChat(Player from, String text)`:
    - Формирует `Message` типа `CHAT` с `playerId`/`playerName` отправителя.
    - Рассылает JSON всем игрокам `players.values()` через `Player.sendLine(json)`.

Таким образом, реализован цикл «приём → разбор → обработка → отправка», совместимый с описанным форматом сообщений.

### 5. GameState и режимы

#### 5.1. GameMode

`GameMode` описывает режим комнаты:

- `GUESS_DRAWING` — режим «Угадай, что рисую».
- `DEAF_PHONE` — режим «Глухой телефон».

Enum позволяет расширять список режимов без изменения сигнатур.

#### 5.2. GameState

`GameState` хранит состояние одной комнаты:

- `roomId` — идентификатор комнаты.
- `mode` — текущий `GameMode`.
- `players` — список `Player`, присоединённых к комнате.
- `round` — номер текущего раунда.
- `timerSeconds` — оставшееся время раунда в секундах.

Основные методы:

- `addPlayer(Player)` / `removePlayer(Player)` — управление составом комнаты.
- `nextRound()` / `resetRound()` — переключение раундов.
- `setTimerSeconds(int)` / `decrementTimer()` — управление таймером.

Сервер в дальнейшем будет использовать `GameState` для реализации логики режимов, обработки READY/START, DRAW, GUESS, TEXT_SUBMIT/ROUND_UPDATE и финальных цепочек.

---

## Протокол и сообщения

### Формат JSON-сообщения

Все сообщения между клиентом и сервером передаются в виде одной JSON-строки, описываемой классом `Message`:

```json
{
"type": "CHAT",
"roomId": 1,
"playerId": 10,
"playerName": "Danya",
"payload": "hello"
}
```


Поля:

- `type` — тип сообщения (`MessageType`).
- `roomId` — идентификатор комнаты.
- `playerId` — идентификатор отправителя.
- `playerName` — имя отправителя.
- `payload` — содержимое сообщения (строка или вложенный JSON в виде строки).

### Типы сообщений (MessageType)

- JOIN – присоединение к комнате (roomId, playerName, режим в payload при необходимости)
- CHAT – сообщение в чат комнаты (text в payload)
- DRAW – данные мазка (координаты, цвет, толщина в payload)
- GUESS – попытка угадать слово (guess в payload)
- CORRECT – ответ сервера при правильном угадывании (correctPlayer, word, score в payload)
- READY – статус готовности игрока в комнате
- START – запуск раунда (roundDuration, totalPlayers, stage в payload)
- TEXT_SUBMIT – отправка текста/описания в режиме “глухого телефона”
- ROUND_UPDATE – переход этапа “глухого телефона” (content, contentType, roundNumber в payload)
- FINAL_CHAIN — финальная цепочка режима 2 (в реализации сервер шлёт ROUND_UPDATE с contentType="FINAL_CHAIN" и полем chain в payload).
- ERROR – ошибка протокола (code, message в payload)


### Обработчики на сервере

Сервер разбирает входящее сообщение и передаёт его в `routeMessage(Player, Message)`:

```java
private void routeMessage(Player player, Message message) {
    if (message.getType() == null) {
        return;
    }
    switch (message.getType()) {
    case JOIN:
        handleJoin(player, message);
        break;
    case CHAT:
        handleChat(player, message);
        break;
    case DRAW:
        handleDraw(player, message);
        break;
    case GUESS:
        handleGuess(player, message);
        break;
    case READY:
        handleReady(player, message);
        break;
    case START:
        handleStart(player, message);
        break;
    case TEXT_SUBMIT:
        handleTextSubmit(player, message);
        break;
    default:
        break;
    }
}
```
Кратко:

- `handleJoin` — добавляет игрока в `GameState` комнаты и рассылает обновлённый список игроков.
- `handleChat` — рассылает сообщение чата всем игрокам комнаты.
- `handleDraw` — ретранслирует данные мазка (`payload`) всем игрокам комнаты.
- `handleGuess` — сравнивает текст `payload` с загаданным словом комнаты, при совпадении шлёт `CORRECT`.
- `handleReady` — отмечает игрока как готового и шлёт информацию о количестве готовых/всего.
- `handleStart` — инициализирует раунд (таймер, номер раунда) и рассылает `START`.
- `handleTextSubmit` — в упрощённом виде пересылает текст следующему игроку по кругу с `ROUND_UPDATE`.

---

## Логика режимов и таймер раундов

### Структура серверной части

- `GameState` — состояние одной комнаты: `roomId`, `mode` (`GUESS_DRAWING`/`DEAF_PHONE`), список игроков, номер раунда `round`, таймер `timerSeconds`, а также `chains: Map<Integer, List<ChainStep>>` для режима «глухой телефон».
- `GameServer` — точка входа, хранит `Map<Integer, GameState> rooms`, секретные слова `secretWords`, готовность игроков `readyPlayers`, список слов `words`, планировщик раундов `ScheduledExecutorService roundScheduler` и методы обработки всех типов сообщений.
- `ChainStep` — один шаг цепочки режима 2: либо текст (`text`), либо рисунок (`drawing` в байтах), признак шага хранится в `isTextStep`.


### Режим 1: «Угадай что рисую»

- При `JOIN` в `handleJoin` сервер создаёт при необходимости `GameState(roomId, GameMode.GUESS_DRAWING)`, кладёт его в `rooms` и добавляет игрока в комнату.
- При `START` в `handleStart` при режиме `GUESS_DRAWING` сервер:
    - задаёт длительность раунда `roundDuration`, сохраняет её в `room.setTimerSeconds(roundDuration)` и сбрасывает номер раунда `room.resetRound()`;
    - выбирает слово через `generateWord()` (из списка, загруженного из файла) и сохраняет в `secretWords.put(roomId, word)`;
    - рассылает всем игрокам сообщение `START` с полями `roundDuration`, `totalPlayers`, `stage`;
    - запускает таймер раунда через `scheduleRoundEnd(roomId, roundDuration)`, который планирует вызов `endRound(roomId)`.
- При `GUESS` в `handleGuess` сервер:
    - достаёт секретное слово по `roomId` из `secretWords` и сравнивает его с `payload` (игнор регистра, `trim`);
    - при пустом слове/угадывании отправляет `ERROR` с кодом `400`; при совпадении рассылает всем игрокам `CORRECT` с информацией об угадавшем и слове, а затем досрочно завершает раунд вызовом `endRound(roomId)`.


### Режим 2: «Глухой телефон»

- Комната для режима 2 создаётся как `GameState(roomId, GameMode.DEAF_PHONE)`, игроки заходят через `JOIN`, а готовность отмечают сообщениями `READY` (учитывается в `readyPlayers`).
- При `START` в режиме `DEAF_PHONE` сервер:
    - сбрасывает номер раунда `room.resetRound()` и очищает цепочки `room.clearChains()`;
    - задаёт `roundDuration`, сохраняет его в состоянии комнаты и рассылает `START` с длительностью и количеством игроков;
    - запускает таймер раунда через `scheduleRoundEnd`.
- При `TEXT_SUBMIT` в режиме `DEAF_PHONE`:
    - сервер проверяет наличие комнаты, режим `DEAF_PHONE` и непустой текст, иначе шлёт `ERROR` с кодами `404`/`400`;
    - добавляет новый `ChainStep(message.getPayload())` в `chains[from.getId()]`;
    - определяет следующего игрока по кругу и отправляет ему `ROUND_UPDATE` с `content` (текст), `contentType="TEXT"` и `roundNumber` комнаты.
- При `DRAW` в режиме `DEAF_PHONE`:
    - проверяется существование комнаты и режим, пустой `payload` даёт `ERROR` с кодом `400` и сообщением «Пустой рисунок»;
    - в `chains[from.getId()]` добавляется `ChainStep(message.getPayload().getBytes())`;
    - отдельно всем игрокам рассылается `DRAW` с содержимым рисунка (для отображения мазков на клиентах).
- По окончании раунда в режиме 2 `endRound` вызывает `sendFinalChains(room)`:
    - берётся цепочка шагов из `room.getChains()` (в тестах — для одного автора), по ней строится JSON‑массив `chain` из объектов `{ "type": "TEXT"/"DRAW", "value": ... }`, для рисунков данные кодируются в base64;
    - формируется `payload` вида `{"contentType":"FINAL_CHAIN","chain":[...]}`;
    - каждому игроку комнаты отправляется одно сообщение `MessageType.ROUND_UPDATE` с этим `payload`, так что все получают полную последовательность шагов.


### Таймер раундов

- Используется один `ScheduledExecutorService roundScheduler`, создаваемый как `Executors.newScheduledThreadPool(1)` внутри `GameServer`.
- В `handleStart` всегда вызывается `scheduleRoundEnd(roomId, roundDuration)`, который через `roundScheduler.schedule(() -> endRound(roomId), roundDuration, TimeUnit.SECONDS)` планирует завершение текущего раунда.
- Метод `endRound`:
    - для `GUESS_DRAWING` рассылает `ROUND_UPDATE` с финальным словом всем игрокам, если оно было задано;
    - для `DEAF_PHONE` вызывает `sendFinalChains(room)`, который собирает и рассылает финальные цепочки.


### Обработка ошибок протокола

- Парсер `parseMessage`:
    - проверяет, что строка — корректный JSON‑объект по формату `{...}`;
    - разбирает поля `type`, `roomId`, `playerId`, `playerName`, `payload` и создаёт `Message`; при любой ошибке парсинга или неизвестном `type` возвращает `null`.
- В `handleClient` при `message == null` отправляется `ERROR` с кодом `400` и текстом «Некорректное сообщение» через `sendError`.
- В `routeMessage`:
    - при `message.getType() == null` шлётся `ERROR` с кодом `400` и текстом «Тип сообщения не задан»;
    - при неизвестном `MessageType` используется ветка `default`, которая отправляет `ERROR` с кодом `400` и текстом «Неизвестный тип сообщения: ...».
- В хендлерах (`handleChat`, `handleDraw`, `handleGuess`, `handleReady`, `handleStart`, `handleTextSubmit`) проверяются существование комнаты, корректность режима и непустые данные, при нарушениях отправляется `ERROR` с кодами `404`/`400` и поясняющим сообщением в JSON‑payload (`code`, `message`).
