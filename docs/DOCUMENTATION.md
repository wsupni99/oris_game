## Содержание
- [ТЗ](#Задание)
- [Установка и запуск](#запуск)
- [Протокол обмена данными](#протокол-обмена-данными)
- [Git-шпаргалка](#шпаргалка-по-git)
- [Сервер: базовая сеть и модель](#сервер-базовая-сеть-и-модель)
---

## Задание

**Цель:** Реализовать сетевую игру для 2+ игроков на Java (JavaFX + сокеты). Client-Server-Client архитектура. Собственный протокол с 4+ типами сообщений. GUI с рисованием (Graphics) и чатом. Многопоточность для сети/интерфейса.

**Репозиторий преподавателя:** В 11_402 есть примеры сокетов (Сокеты1/2 записи). Бери структуру Client/Server оттуда.

**Требования к коду (строго):**

- Только чистые сокеты + JavaFX (без Spring/Netty).
- Минимум комментариев.
- Каждый в группе знает весь код.
- Протокол: JSON/байты с типами сообщений (минимум 4 видимых игроку).
- Рисование: Canvas с Graphics2D для рисовалки.
- Многопоточность: ExecutorService для сетевых задач.


## Режимы игры

### 1. "Угадай что рисую" (2+ игрока)

- Сервер: Создаёт комнату (порт 8080).
- Клиенты: Подключаются по IP:порт.
- Админ (хост) рисует на Canvas (линия, цвет, стирание).
- Остальные: Чат для загаданного слова + поле ввода.
- Детект: Сервер сравнивает текст с загадкой (простой match).
- Видимые сообщения:

1. `DRAW` - координаты мазка (x,y,цвет).
2. `GUESS` - текст догадки.
3. `CORRECT` - "Угадал! Слово: ...".
4. `CHAT` - обычные сообщения.


### 2. "Глухой телефон" (4+ игрока)

- Админ создаёт комнату, все жмут "Готов".
- Админ жмёт "Старт" + таймер раунда (30-60с).
- Раунды:

1. Все пишут предложение (текст → сервер).
2. Сдвиг: Каждый получает текст предыдущего → рисует.
3. Сдвиг: Каждый получает рисунок следующего → описывает текстом.
4. Повтор до круга.
- Финал: Сервер шлёт последовательность (текст1 → рис1 → текст2 → рис2...).
- Видимые сообщения:

1. `TEXT_SUBMIT` - отправка текста/описания.
2. `DRAW_UPDATE` - мазки для рисовалки.
3. `NEXT_ROUND` - "Получили: [текст/картинка]".
4. `FINAL_CHAIN` - вся цепочка.

## Архитектура (Client/Server) — JavaFX

Server:
- ServerSocket (8080)
- HashMap<Socket, Player> (игроки)
- ExecutorService для обработки клиентов
- GameState (roomId, режим, раунд, таймер)

Client:
- Socket → ObjectOutputStream/InputStream
- JavaFX Stage/Scene
- Canvas (javafx.scene.canvas.Canvas) + GraphicsContext для рисования
- VBox/HBox/BorderPane для раскладки
- TextArea (чат), TextField (ввод), Button (Готов/Старт/Отправить), Label (таймер/статус)
- Отдельный поток для сети + Platform.runLater(...) для обновления UI

Протокол (JSON пример):
{ "type": "DRAW", "data": {x:10,y:20,color:"red",size:2} }
{ "type": "GUESS", "data": "кот" }


## GUI и рисование (3 балла) — JavaFX

- Компоненты: Button (Готов/Старт/Очистить), TextField (ввод), TextArea (чат/цепочка), ComboBox<String> (цвета), Label (таймер/статус).
- Рисование: Canvas, обработчики setOnMousePressed / setOnMouseDragged → GraphicsContext.strokeLine(...). Сохранять strokes как List<StrokeDto> (последовательность точек) для отправки/рендера.
- Адаптивность: BorderPane/ VBox / HBox, привязки по ширине/высоте (bind), использование Scene и resizeable Stage; обновление Canvas через перерисовку по данным с сервера в Platform.runLater.


**Дедлайн:** Прототип к 20.12, финал к 25.12. 

- - -

## Запуск
```mvn javafx:run```

---
# Протокол обмена данными

Все сообщения передаются в JSON между клиентом и сервером через TCP-сокеты.

## Структура сообщения

- `type` — тип сообщения (JOIN, CHAT, DRAW и т.д.)
- `roomId` — ID комнаты
- `playerId` — ID отправителя
- `playerName` — имя отправителя
- `payload` — данные сообщения

---

## Типы сообщений

| Тип | Направление | Описание |
|-----|-------------|---------|
| JOIN | Клиент → Сервер | Присоединение к комнате (gameMode, isHost) |
| CHAT | Клиент → Сервер → Все | Сообщение в чате (text) |
| DRAW | Клиент → Сервер → Все | Мазок на холсте режима 1 (x1, y1, x2, y2, color, size) |
| GUESS | Клиент → Сервер | Угадывание слова режима 1 (guess) |
| CORRECT | Сервер → Все | Уведомление об угадывании (correctPlayer, word, score) |
| READY | Клиент → Сервер | Игрок готов режима 2 (ready) |
| START | Сервер → Все | Начало игры режима 2 (roundDuration, totalPlayers, stage) |
| TEXT_SUBMIT | Клиент → Сервер | Отправка текста режима 2 (text, stage) |
| ROUND_UPDATE | Сервер → Все | Переход этапа режима 2 (stage, content, contentType, roundNumber) |
| FINAL_CHAIN | Сервер → Все | Финальная цепочка режима 2 (chains с текстами и рисунками) |
| ERROR | Сервер → Клиент | Ошибка сервера (code, message) |

---

## Коды ошибок

| Код | Описание |
|-----|---------|
| 400 | Некорректное сообщение |
| 403 | Нет прав (только для хоста) |
| 404 | Комната не найдена |
| 409 | Игра уже началась |
| 412 | Недостаточно игроков |


---

# Шпаргалка по Git

Пользуйтесь верхним меню **Git** или горячими клавишами. Командная строка не нужна.

## 1. Начало работы (Clone)
*Если проекта еще нет на компьютере:*
1. **File** → **New** → **Project from Version Control...**
2. Вставьте ссылку на репозиторий (URL).
3. Нажмите **Clone**.

## 2. Перед началом работы (Pull)
*Всегда делайте это перед тем, как писать код, чтобы не было конфликтов:*
1. Нажмите на синюю стрелку `⬇` в правом верхнем углу (или **Ctrl + T**).
2. Выберите `Merge` в окне (если спросит) и нажмите **OK**.

## 3. Сохранение изменений (Commit)
*Когда написали часть кода и хотите «зафиксировать» его:*
1. Нажмите **Ctrl + K** (или вкладка **Commit** слева).
2. Отметьте галочками нужные файлы.
3. Напишите понятный комментарий (напр: `feat: добавил холст для рисования`).
4. Нажмите кнопку **Commit** (только сохранит локально) или стрелочку рядом → **Commit and Push** (сразу отправит на GitHub).

## 4. Отправка на GitHub (Push)
*Если сделали просто Commit, его нужно «залить» в облако:*
1. Нажмите **Ctrl + Shift + K** (или зелёная стрелка `⬆` в углу).
2. Нажмите **Push**.

## 5. Если возник конфликт (Conflicts)
*Если вы и напарник изменили одну и ту же строку:*
1. При `Pull` или `Push` вылезет окно **Conflicts**.
2. Нажмите **Merge...**.
3. Откроется три окна:
    - **Слева (Your):** ваш код.
    - **Справа (Theirs):** код напарника.
    - **Центр (Result):** что получится в итоге.
4. Нажимайте на стрелочки `>>`, чтобы перенести нужные изменения в центр.
5. Когда закончите, нажмите **Apply**.

## 6. Как не сломать проект (Золотые правила)
1. **Pull** — каждое утро/вечер перед работой.
2. **Commit** — после каждой законченной маленькой задачи.
3. **Сообщения** — пишите честно, что сделали в коммите.
4. **Общение** — если лезете в файлы напарника, лучше предупредите в чате.

---
**Горячие клавиши для запоминания:**
- `Ctrl + T` — Обновить (Pull)
- `Ctrl + K` — Закоммитить (Commit)
- `Ctrl + Shift + K` — Отправить (Push)

---
## Сервер: базовая сеть и модель

### 1. Архитектура пакетов

- `ru.itis.garticphone.common`
    - `MessageType` — enum с типами сообщений протокола.
    - `Message` — структура одного JSON-сообщения (type, roomId, playerId, playerName, payload).
- `ru.itis.garticphone.client`
    - `PlayerState` — enum состояний игрока на стороне сервера.
    - `Player` — серверное представление подключённого игрока (метаданные + сокет + потоки).
- `ru.itis.garticphone.server`
    - `GameServer` — основной сервер: поднимает ServerSocket, принимает клиентов, обрабатывает сообщения.
    - `GameState`/`GameMode` — состояние комнаты (roomId, режим, список игроков, раунд, таймер).

### 2. Сетевой слой сервера

#### 2.1. Запуск сервера

- `GameServer` поднимает `ServerSocket` на порту `8080`.
- Для обработки клиентов используется `ExecutorService` (`newCachedThreadPool`).
- Каждый новый `Socket` от `accept()` передаётся в пул через `executorService.submit(() -> handleClient(socket))`.

#### 2.2. Модель игрока

`Player` инкапсулирует данные о клиенте:

- `id` — уникальный идентификатор игрока на сервере.
- `name` — имя/ник игрока.
- `state` (`PlayerState`) — состояние: `CONNECTED`, `IN_LOBBY`, `IN_GAME`, `DISCONNECTED`.
- `socket` — TCP-соединение с клиентом.
- `in` / `out` — `BufferedReader` и `PrintWriter` для приёма и отправки строк.

Сервер хранит всех игроков в `Map<Socket, Player> players`.

### 3. Протокол сообщений

#### 3.1. Типы сообщений

`MessageType` определяет фиксированный набор типов:

- `JOIN`, `CHAT`, `DRAW`, `GUESS`, `CORRECT`,
- `READY`, `START`, `TEXT_SUBMIT`, `ROUND_UPDATE`, `FINAL_CHAIN`, `ERROR`.

Это исключает магические строки и гарантирует, что протокол использует только корректные типы.

#### 3.2. Формат сообщения

Класс `Message` задаёт контракт JSON-сообщения:

- `type` — `MessageType` (например, `CHAT`).
- `roomId` — идентификатор комнаты.
- `playerId` — идентификатор отправителя.
- `playerName` — имя отправителя.
- `payload` — строковые данные (текст чата, JSON с координатами мазков, код ошибки и т.д.).

На проводе сообщение передаётся как одна JSON-строка, совместимая со структурой `Message`.

### 4. Цикл приёма/отправки на сервере

#### 4.1. Приём сообщений

Метод `handleClient(Socket socket)`:

- Создаёт потоки `BufferedReader in` и `PrintWriter out`.
- Регистрирует нового игрока (`Player`) и кладёт его в `players`.
- Входит в цикл:

    - читает строку: `line = in.readLine();`
    - парсит её в `Message message = parseMessage(line);`
    - при ошибке парсинга отправляет клиенту `ERROR` с кодом `400`.
    - передаёт сообщение в `routeMessage(player, message)` для логики.

Цикл работает до разрыва соединения. После выхода игрок удаляется из `players`, сокет закрывается.

#### 4.2. Отправка сообщений

- Для ответа/бродкаста сервер создаёт `Message` и преобразует его в JSON-строку методом `toJson(Message)`.
- Для чата используется `broadcastChat(Player from, String text)`:
    - Формирует `Message` типа `CHAT` с `playerId`/`playerName` отправителя.
    - Рассылает JSON всем игрокам `players.values()` через `Player.sendLine(json)`.

Таким образом, реализован цикл «приём → разбор → обработка → отправка», совместимый с описанным форматом сообщений.

### 5. GameState и режимы

#### 5.1. GameMode

`GameMode` описывает режим комнаты:

- `GUESS_DRAW` — режим «Угадай, что рисую».
- `TELEPHONE` — режим «Глухой телефон».

Enum позволяет расширять список режимов без изменения сигнатур.

#### 5.2. GameState

`GameState` хранит состояние одной комнаты:

- `roomId` — идентификатор комнаты.
- `mode` — текущий `GameMode`.
- `players` — список `Player`, присоединённых к комнате.
- `round` — номер текущего раунда.
- `timerSeconds` — оставшееся время раунда в секундах.

Основные методы:

- `addPlayer(Player)` / `removePlayer(Player)` — управление составом комнаты.
- `nextRound()` / `resetRound()` — переключение раундов.
- `setTimerSeconds(int)` / `decrementTimer()` — управление таймером.

Сервер в дальнейшем будет использовать `GameState` для реализации логики режимов, обработки READY/START, DRAW, GUESS, TEXT_SUBMIT/ROUND_UPDATE и финальных цепочек.

---